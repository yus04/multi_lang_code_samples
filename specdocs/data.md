# データ仕様書  
   
## 1. 概要  
   
本仕様書は、IMS バッチプログラムで使用するデータの構造および仕様について記述します。このデータ仕様書は、プログラム開発およびデータベース設計の基礎資料として使用されます。  
   
## 2. データベース概要  
   
IMS データベースは、以下のセグメントで構成されています。  
   
- **ルートセグメント**: 顧客情報を保持  
- **レベル1セグメント**: 顧客の注文情報を保持  
- **レベル2セグメント**: 注文の詳細情報を保持  
   
## 3. セグメント定義  
   
### 3.1 ルートセグメント（CUSTOMER）  
   
- **セグメント名**: CUSTOMER  
- **キー長**: 8 バイト  
- **説明**: 顧客の基本情報を保持するセグメント  
   
#### 3.1.1 フィールド定義  
   
| フィールド名   | データ型     | 長さ | 開始位置 | 説明                 |  
|----------------|--------------|------|----------|----------------------|  
| CUSTOMER_ID    | CHAR(8)      | 8    | 1        | 顧客ID（主キー）     |  
| CUSTOMER_NAME  | CHAR(20)     | 20   | 9        | 顧客名               |  
| ADDRESS        | CHAR(50)     | 50   | 29       | 住所                 |  
| PHONE_NUMBER   | CHAR(12)     | 12   | 79       | 電話番号             |  
   
### 3.2 レベル1セグメント（ORDER）  
   
- **セグメント名**: ORDER  
- **キー長**: 12 バイト  
- **親セグメント**: CUSTOMER  
- **説明**: 顧客の注文情報を保持するセグメント  
   
#### 3.2.1 フィールド定義  
   
| フィールド名   | データ型     | 長さ | 開始位置 | 説明                 |  
|----------------|--------------|------|----------|----------------------|  
| ORDER_ID       | CHAR(12)     | 12   | 1        | 注文ID（主キー）     |  
| ORDER_DATE     | CHAR(8)      | 8    | 13       | 注文日（YYYYMMDD）   |  
| TOTAL_AMOUNT   | PACKED(7,2)  | 5    | 21       | 注文合計金額         |  
   
### 3.3 レベル2セグメント（ORDER_DETAIL）  
   
- **セグメント名**: ORDER_DETAIL  
- **キー長**: 4 バイト  
- **親セグメント**: ORDER  
- **説明**: 注文の詳細情報を保持するセグメント  
   
#### 3.3.1 フィールド定義  
   
| フィールド名   | データ型     | 長さ | 開始位置 | 説明                |  
|----------------|--------------|------|----------|---------------------|  
| ITEM_NO        | CHAR(4)      | 4    | 1        | 明細番号（主キー）  |  
| PRODUCT_CODE   | CHAR(10)     | 10   | 5        | 商品コード          |  
| QUANTITY       | PACKED(5,0)  | 3    | 15       | 数量                |  
| ITEM_AMOUNT    | PACKED(7,2)  | 5    | 18       | 金額                |  
   
## 4. データモデル  
   
### 4.1 階層構造  
   
- **CUSTOMER**（ルートセグメント）  
  - **ORDER**（レベル1セグメント）  
    - **ORDER_DETAIL**（レベル2セグメント）  
   
### 4.2 リレーションシップ  
   
- **1対多関係**:  
  - 1つの顧客（CUSTOMER）は複数の注文（ORDER）を持つことができる。  
  - 1つの注文（ORDER）は複数の注文詳細（ORDER_DETAIL）を持つことができる。  
   
## 5. データアクセス仕様  
   
### 5.1 セグメントの取得  
   
- **GU（Get Unique）**:  
  - 特定のキーを使用して、ルートセグメント（CUSTOMER）を一意に取得する。  
- **GNP（Get Next within Parent）**:  
  - 現在の親セグメント内で、次の子セグメントを取得する。  
   
### 5.2 セグメントの挿入  
   
- **ISRT（Insert）**:  
  - 新しいセグメントをデータベースに挿入する。  
  - 順序:  
    1. 親セグメントをポインタが指している状態で実行。  
    2. 挿入するセグメントのデータを I/O エリアに設定。  
    3. DL/I コールを実行して挿入。  
   
### 5.3 セグメントの更新  
   
- **REPL（Replace）**:  
  - 既存のセグメントのデータを更新する。  
  - 手順:  
    1. 更新対象のセグメントを取得する（例: GU で取得）。  
    2. 更新するフィールドを変更。  
    3. DL/I コールを実行して更新。  
   
### 5.4 セグメントの削除  
   
- **DLET（Delete）**:  
  - 既存のセグメントを削除する。  
  - 手順:  
    1. 削除対象のセグメントを取得する。  
    2. DL/I コールを実行して削除。  
   
## 6. SSA（Segment Search Argument）の仕様  
   
### 6.1 資格条件付き SSA  
   
- 特定のキー値を指定してセグメントを取得する際に使用。  
- 書式:  
  ```  
  セグメント名(フィールド名 オペレーター 値)  
  ```  
- 例:  
  ```  
  CUSTOMER(CUSTOMER_ID = 'CUST0001')  
  ```  
   
### 6.2 資格条件なし SSA  
   
- セグメント名のみを指定し、順次取得する際に使用。  
- 書式:  
  ```  
  セグメント名  
  ```  
- 例:  
  ```  
  ORDER  
  ```  
   
## 7. フィールドデータタイプの詳細  
   
- **CHAR(n)**: n バイトの固定長文字列。  
- **PACKED(m,n)**: 合計 m 桁、少数部 n 桁のパック10進数。  
  - **注意**: バイト長は `(m + 1) / 2` バイトとなる。  
   
## 8. ステータスコードの処理  
   
- DL/I コールの後には必ずステータスコードを確認する。  
- **主なステータスコード**:  
  - **'  '**: 正常終了  
  - **'GE'**: 指定したセグメントやキーが存在しない。  
  - **'II'**: 無効な SSA またはコマンド。  
  - **'AO'**: アクセスが不許可。  
- ステータスコードに応じて、適切なエラーメッセージやリカバリ処理を実装する。  
   
## 9. サンプルプログラムのフロー  
   
1. **顧客情報の取得**:  
   - 顧客IDを指定して、CUSTOMER セグメントを GU で取得。  
2. **注文情報の取得**:  
   - 取得した CUSTOMER セグメントを親として、ORDER セグメントを GN または GNP で取得。  
3. **注文詳細の取得**:  
   - 取得した ORDER セグメントを親として、ORDER_DETAIL セグメントを GN または GNP で取得。  
4. **データの処理**:  
   - 必要な情報を集計・表示・更新などの処理を行う。  
5. **終了処理**:  
   - データベースの接続を終了し、プログラムを正常に終了する。  
   
## 10. 注意事項  
   
- **排他制御**:  
  - データ更新時には、必要に応じて排他制御を行う（例えば、GHU コールを使用）。  
- **エラーハンドリング**:  
  - ステータスコードを確認し、エラー時には適切な処理を行う。  
- **データの整合性**:  
  - データの挿入・更新・削除の際には、親子関係が崩れないように注意する。  
